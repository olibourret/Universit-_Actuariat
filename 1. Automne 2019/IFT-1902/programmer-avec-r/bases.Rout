
R Under development (unstable) (2019-07-23 r76873) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

> options(error=expression(NULL))
> ## Copyright (C) 2019 Vincent Goulet
> ##
> ## Ce fichier fait partie du projet
> ## «Programmer avec R»
> ## https://gitlab.com/vigou3/programmer-avec-r
> ##
> ## Cette création est mise à disposition sous licence
> ## Attribution-Partage dans les mêmes conditions 4.0
> ## International de Creative Commons.
> ## https://creativecommons.org/licenses/by-sa/4.0/
> 
> ###
> ### DONNÉES ET PROCÉDURES FONDAMENTALES  
> ###
> 
> ## NOMBRES ET OPÉRATEURS ARITHMÉTIQUES
> 
> ## Tous les nombres réels sont stockés en double précision
> ## dans R, entiers comme fractionnaires. R permet aussi de
> ## définir des nombres en notation scientifique et des nombres
> ## complexes.
> 486                        # nombre réel entier
[1] 486
> 0.3324                     # nombre réel fractionnaire
[1] 0.3324
> 2e-3                       # notation scientifique
[1] 0.002
> 1 + 2i                     # nombre complexe
[1] 1+2i
> 
> ## La définition des opérateurs arithmétiques standards coule
> ## de source.
> 137 + 349                  # addition
[1] 486
> 1000 - 334                 # soustraction
[1] 666
> 5 * 42                     # multiplication
[1] 210
> 10/4                       # division
[1] 2.5
> 2^3                        # puissance
[1] 8
> -42                        # changement de signe
[1] -42
> 
> ## Les opérateurs de comparaison (égalité et inégalité)
> ## retournent une valeur booléenne.
> 486 < 521                  # plus petit
[1] TRUE
> 486 >= 521                 # plus grand ou égal
[1] FALSE
> 486 != 521                 # différent de
[1] TRUE
> 
> ## Attention à cette erreur commune --- et parfois difficile à
> ## détecter: '=' n'est PAS l'opérateur de comparaison de
> ## l'égalité entre deux valeurs.
> 5 = 2                      # erreur de syntaxe
Error in 5 = 2 : membre gauche de l'assignation (do_set) incorrect
> 
> ## L'opérateur de comparaison est plutôt '=='.
> 486 == 486                 # comparaison
[1] TRUE
> y = 486                    # pas un test...
> y                          # ... plutôt une affectation
[1] 486
> 
> ## Les opérateurs '==' et '!=' vérifient l'égalité (ou non)
> ## bit pour bit dans la représentation interne des nombres
> ## dans l'ordinateur. Ça fonctionne bien pour les entiers ou
> ## les valeurs booléennes, mais pas pour les nombres réels ou,
> ## plus insidieux, pour les nombres entiers provenant d'un
> ## calcul et qui ne sont entiers qu'en apparence.
> ##
> ## [Pour en savoir (un peu) plus:
> ##  https://floating-point-gui.de/formats/fp/]
> 1.2 + 1.4 + 2.8            # 5.4 en apparence
[1] 5.4
> 1.2 + 1.4 + 2.8 == 5.4     # non?!?
[1] FALSE
> 0.3/0.1 == 3               # à gauche: faux entier
[1] FALSE
> 
> ## L'opérateur ':' est très utile pour générer des suites de
> ## nombres avec un pas fixe de 1 entre chaque nombre.
> 1:10                       # entiers de 1 à 10
 [1]  1  2  3  4  5  6  7  8  9 10
> 5:-2                       # entiers de 5 à -2
[1]  5  4  3  2  1  0 -1 -2
> 
> ## L'opérateur modulo retourne le reste d'une division.
> 544 %% 119                 # 544/119 = 4 reste 68
[1] 68
> 119 %% 544                 # x %% y = x si x < y
[1] 119
> 
> ## La division entière est l'opération duale du modulo: elle
> ## retourne la partie entière d'une division.
> 544 %/% 119                # 544/119 = 4 reste 68
[1] 4
> 119 %/% 544                # x %/% y = 0 si x < y
[1] 0
> 
> ## L'opérateur modulo est souvent utilisé pour déterminer si
> ## un nombre est pair ou impair. Un nombre 'x' est pair si 'x
> ## mod 2 = 0' et il est impair si 'x mod 2 = 1'.
> 554 %% 2                   # pair
[1] 0
> 119 %% 2                   # impair
[1] 1
> 
> ## CHAINES DE CARACTÈRES
> 
> ## On crée une chaine de caractères en l'entourant de
> ## guillemets doubles " ".
> "a"                        # chaine de 1 caractère
[1] "a"
> "foobar"                   # chaine de 6 caractères
[1] "foobar"
> "486"                      # chaine de 3 caractères
[1] "486"
> 
> ## Les opérateurs de comparaison sont également définis pour
> ## les chaines de caractères en fonction de l'ordre
> ## lexicographique. Attention: c'est un terrain miné selon la
> ## langue utilisée; consultez la rubrique d'aide de
> ## 'Comparison' au besoin (qui vous dira de ne pas faire
> ## d'hypothèses sur l'ordre lexicographique entre deux chaines
> ## de caractères). Quelques exemples simples.
> "a" < "d"                  # ordre alphabétique
[1] TRUE
> "a" < "A"                  # minuscules avant majuscules
[1] TRUE
> "1" < "a"                  # chiffres avant lettres
[1] TRUE
> 
> ## VALEURS BOOLÉENNES
> 
> ## 'TRUE' et 'FALSE' sont des noms réservés pour identifier
> ## les valeurs booléennes correspondantes.
> TRUE                       # vrai
[1] TRUE
> FALSE                      # faux
[1] FALSE
> !TRUE                      # négation logique
[1] FALSE
> TRUE & FALSE               # ET logique
[1] FALSE
> TRUE | FALSE               # OU logique
[1] TRUE
> 
> ## [Les expressions suivantes (qui anticipent sur la suite)
> ## construisent les tables de vérité du Et logique et du OU
> ## logique.]
> p <- c(TRUE, TRUE, FALSE, FALSE)
> q <- c(TRUE, FALSE, TRUE, FALSE)
> cbind("p" = p, "q" = q, "p ET q" = p & q)
         p     q p ET q
[1,]  TRUE  TRUE   TRUE
[2,]  TRUE FALSE  FALSE
[3,] FALSE  TRUE  FALSE
[4,] FALSE FALSE  FALSE
> cbind("p" = p, "q" = q, "p OU q" = p | q)
         p     q p OU q
[1,]  TRUE  TRUE   TRUE
[2,]  TRUE FALSE   TRUE
[3,] FALSE  TRUE   TRUE
[4,] FALSE FALSE  FALSE
> 
> ## AUTRES DONNÉES FONDAMENTALES DE R
> 
> ## Donnée manquante. 'NA' est un nom réservé pour représenter
> ## une donnée manquante.
> NA                         # valeur admissible
[1] NA
> NA + 2                     # tout calcul avec 'NA' donne NA
[1] NA
> 
> ## Valeurs infinies et indéterminée. 'Inf', '-Inf' et 'NaN'
> ## sont des noms réservés.
> 1/0                        # +infini
[1] Inf
> -1/0                       # -infini
[1] -Inf
> 0/0                        # indétermination
[1] NaN
> 
> ## Valeur "néant". 'NULL' est un nom réservé pour représenter
> ## le néant, rien.
> NULL                       # valeur admissible
NULL
> NULL + 2                   # aucun calcul possible avec néant 
numeric(0)
> 
> ###
> ### COMMANDES R            
> ###
> 
> ## Les expressions entrées à la ligne de commande sont
> ## immédiatement évaluées et le résultat est affiché à
> ## l'écran, comme avec une grosse calculatrice.
> 1                          # une constante
[1] 1
> (2 + 3 * 5)/7              # priorité des opérations
[1] 2.428571
> 3^5                        # puissance
[1] 243
> exp(3)                     # fonction exponentielle
[1] 20.08554
> sin(pi/2) + cos(pi/2)      # fonctions trigonométriques
[1] 1
> gamma(5)                   # fonction gamma
[1] 24
> 
> ## Lorsqu'une expression est syntaxiquement incomplète,
> ## l'invite de commande change de '> ' à '+ '.
> 2 -                        # expression incomplète
+ 5 *                        # toujours incomplète
+ 3                          # complétée
[1] -13
> 
> ## Entrer le nom d'un objet affiche son contenu. Pour une
> ## fonction, c'est son code source qui est affiché.
> pi                         # constante numérique intégrée
[1] 3.141593
> letters                    # chaîne de caractères intégrée
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
> LETTERS                    # version en majuscules
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"
> matrix                     # fonction interne
function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 
{
    if (is.object(data) || !is.atomic(data)) 
        data <- as.vector(data)
    .Internal(matrix(data, nrow, ncol, byrow, dimnames, missing(nrow), 
        missing(ncol)))
}
<bytecode: 0x7ff87b066298>
<environment: namespace:base>
> 
> ## On crée des nouveaux objets en leur affectant une valeur
> ## avec l'opérateur '<-'. *Ne pas* utiliser '=' pour
> ## l'affectation.
> x <- 5                     # affectation de 5 à l'objet 'x'
> 5 -> x                     # idem, mais peu utilisé
> x                          # voir le contenu
[1] 5
> (x <- 5)                   # affectation et affichage
[1] 5
> y <- x                     # affecter la valeur de 'x' à 'y'
> x <- y <- 5                # idem, en une seule expression
> y                          # 5
[1] 5
> x <- 0                     # changer la valeur de 'x'...
> y                          # ... ne change pas celle de 'y'
[1] 5
> 
> ## Pour regrouper plusieurs expressions en une seule commande,
> ## il faut soit les séparer par un point-virgule ';', soit les
> ## regrouper à l'intérieur d'accolades { } et les séparer par
> ## des retours à la ligne.
> x <- 5; y <- 2; x + y      # compact; éviter dans les scripts
[1] 7
> x <- 5;                    # éviter les ';' superflus
> {                          # début d'un groupe
+     x <- 5                 # première expression du groupe
+     y <- 2                 # seconde expression du groupe
+     x + y                  # dernière expression du groupe
+ }                          # fin du groupe et résultat
[1] 7
> {x <- 5; y <- 2; x + y}    # valide, mais redondant 
[1] 7
> 
> ###
> ### VECTEURS               
> ###
> 
> ## La fonction de base pour créer des vecteurs est 'c'. Il
> ## peut s'avérer utile de nommer les éléments d'un vecteur.
> x <- c(A = -1, B = 2, C = 8, D = 10) # création d'un vecteur
> names(x)                             # extraire les noms
[1] "A" "B" "C" "D"
> names(x) <- letters[1:length(x)]     # changer les noms
> x                                    # nouveau vecteur
 a  b  c  d 
-1  2  8 10 
> 
> ## Attention aux chaines de caractères! Dans R, une chaine de
> ## caractères n'est pas un vecteur de caractères. Une chaine
> ## est un vecteur de longueur 1 comptant plusieurs caractères.
> ## Un vecteur peut contenir plusieurs chaines de caractères.
> length("foobar")           # *une* chaine de 6 caractères
[1] 1
> c("foo", "bar")            # *deux* chaines de 3 caractères
[1] "foo" "bar"
> length(c("foo", "bar"))    # longueur de 2
[1] 2
> 
> ## La fonction 'vector' sert à initialiser des vecteurs avec
> ## des valeurs prédéterminées. Elle compte deux arguments: le
> ## mode du vecteur et sa longueur. Les fonctions 'numeric',
> ## 'logical', 'complex' et 'character' constituent des
> ## raccourcis pour des appels à 'vector'.
> vector("numeric", 5)       # vecteur initialisé avec des 0
[1] 0 0 0 0 0
> numeric(5)                 # équivalent
[1] 0 0 0 0 0
> numeric                    # en effet, voici la fonction
function (length = 0L) 
.Internal(vector("double", length))
<bytecode: 0x7ff87b909258>
<environment: namespace:base>
> logical(5)                 # initialisé avec FALSE
[1] FALSE FALSE FALSE FALSE FALSE
> complex(5)                 # initialisé avec 0 + 0i
[1] 0+0i 0+0i 0+0i 0+0i 0+0i
> character(5)               # initialisé avec chaînes vides
[1] "" "" "" "" ""
> 
> ## Si l'on mélange dans un même vecteur des objets de mode
> ## différents, il y a conversion forcée vers le mode pour
> ## lequel il y a le moins de perte d'information, c'est-à-dire
> ## vers le mode qui permet le mieux de retrouver la valeur
> ## originale des éléments.
> c(5, TRUE, FALSE)          # conversion en mode 'numeric'
[1] 5 1 0
> c(5, "z")                  # conversion en mode 'character'
[1] "5" "z"
> c(TRUE, "z")               # conversion en mode 'character'
[1] "TRUE" "z"   
> c(5, TRUE, "z")            # conversion en mode 'character'
[1] "5"    "TRUE" "z"   
> 
> ## Les fonctions 'as.numeric', 'as.logical' et 'as.character' sont
> ## utiles pour forcer la conversion d'un mode vers un autre.
> as.logical(1)              # conversion en booléen
[1] TRUE
> as.numeric(TRUE)           # conversion en numérique
[1] 1
> as.character(1)            # conversion en chaine de caractères
[1] "1"
> 
> ### INDIÇAGE
> 
> ## L'indiçage est une opération importante et beaucoup
> ## utilisée. Elle sert à extraire des éléments d'un vecteur
> ## avec la construction 'x[i]', ou à les remplacer avec la
> ## construction 'x[i] <- y'. Les fonctions sous-jacentes sont
> ## '[' et '[<-'.
> ##
> ## Les expressions suivantes illustrent les cinq méthodes
> ## d'indiçage.
> x                          # le vecteur
 a  b  c  d 
-1  2  8 10 
> x[1]                       # extraction par position
 a 
-1 
> "["(x, 1)                  # idem avec la fonction '['
 a 
-1 
> x[-2]                      # suppression par position
 a  c  d 
-1  8 10 
> x[x > 5]                   # extraction par critère
 c  d 
 8 10 
> x["c"]                     # extraction par nom
c 
8 
> x[]                        # tous les éléments
 a  b  c  d 
-1  2  8 10 
> x[numeric(0)]              # différent d'indice vide
named numeric(0)
> 
> ## Laissons tomber les noms de l'objet.
> names(x) <- NULL           # suppression de l'attribut 'names'
> 
> ## Quelques cas spéciaux d'indiçage.
> length(x)                  # rappel de la longueur
[1] 4
> x[1:8]                     # vecteur allongé avec des NA
[1] -1  2  8 10 NA NA NA NA
> x[0]                       # extraction de rien
numeric(0)
> x[0] <- 1; x               # affectation de rien
[1] -1  2  8 10
> x[c(0, 1, 2)]              # indice 0 ignoré
[1] -1  2
> x[c(1, NA, 5)]             # indice NA retourne NA
[1] -1 NA NA
> x[2.6]                     # fractions tronquées vers 0
[1] 2
> 
> ## ARITHMÉTIQUE VECTORIELLE
> 
> ## L'unité de base de l'arithmétique en R est le vecteur. Cela
> ## rend très simple et intuitif de faire des opérations
> ## mathématiques courantes.
> ##
> ## Là où plusieurs langages de programmation exigent des
> ## boucles, R fait le calcul directement.
> ##
> ## En effet, les règles de l'arithmétique en R sont
> ## globalement les mêmes qu'en algèbre vectorielle et
> ## matricielle.
> 5 * c(2, 3, 8, 10)         # multiplication par une constante
[1] 10 15 40 50
> c(2, 6, 8) + c(1, 4, 9)    # addition de deux vecteurs
[1]  3 10 17
> c(0, 3, -1, 4)^2           # élévation à une puissance
[1]  0  9  1 16
> 
> ## Dans les règles de l'algèbre vectorielle, les longueurs des
> ## vecteurs doivent toujours concorder.
> ##
> ## R permet plus de flexibilité en recyclant les vecteurs les
> ## plus courts dans une opération.
> ##
> ## Il n'y a donc à peu près jamais d'erreurs de longueur en R!
> ## C'est une arme à deux tranchants: le recyclage des vecteurs
> ## facilite le codage, mais peut aussi résulter en des
> ## réponses complètement erronées sans que le système ne
> ## détecte d'erreur.
> 8 + 1:10                   # 8 est recyclé 10 fois
 [1]  9 10 11 12 13 14 15 16 17 18
> c(2, 5) * 1:10             # c(2, 5) est recyclé 5 fois
 [1]  2 10  6 20 10 30 14 40 18 50
> c(-2, 3, -1, 4)^(1:4)      # quatre puissances différentes
[1]  -2   9  -1 256
> 
> ## Dans les opérations arithmétiques (ou, plus généralement,
> ## les opérations conçues pour travailler avec des nombres),
> ## les valeurs booléennes TRUE et FALSE sont automatiquement
> ## converties en 1 et 0, respectivement. Conséquence: il est
> ## possible de faire des calculs avec des valeurs booléennes!
> c(5, 3) + c(TRUE, FALSE)   # équivalent à c(5, 3) + c(1, 0)
[1] 6 3
> 5 + (3 < 4)                # (3 < 4) vaut TRUE
[1] 6
> 5 + 3 < 4                  # priorité des opérations!
[1] FALSE
> 
> ## Dans les opérations logiques, ce sont les nombres qui sont
> ## convertis en valeurs booléennes. Dans ce cas, zéro est
> ## traité comme FALSE et tous les autres nombres comme TRUE.
> 0:5 & 5:0
[1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE
> 0:5 | 5:0
[1] TRUE TRUE TRUE TRUE TRUE TRUE
> !0:5
[1]  TRUE FALSE FALSE FALSE FALSE FALSE
> 
> ###
> ### FONCTIONS  
> ###
> 
> ## PROGRAMMATION FONCTIONNELLE
> 
> ## Les fonctions sont des objets comme les autres dans R. Cela
> ## signifie que:
> ##
> ## - le contenu d'une fonction (son code source) est toujours
> ##   accessible;
> ## - une fonction peut accepter en argument une autre
> ##   fonction;
> ## - une fonction peut retourner une fonction comme résultat;
> ## - l'utilisateur peut définir de nouvelles fonctions.
> seq                        # contenu est le code source
function (...) 
UseMethod("seq")
<bytecode: 0x7ff87bb69938>
<environment: namespace:base>
> mode(seq)                  # mode est "function"
[1] "function"
> rep(seq(5), 3)             # fonction argument d'une fonction
 [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
> lapply(1:5, seq)           # idem
[[1]]
[1] 1

[[2]]
[1] 1 2

[[3]]
[1] 1 2 3

[[4]]
[1] 1 2 3 4

[[5]]
[1] 1 2 3 4 5

> mode(ecdf(rpois(100, 1)))  # résultat de ecdf est une fonction
[1] "function"
> ecdf(rpois(100, 1))(5)     # évaluation en un point
[1] 1
> c(seq, rep)                # vecteur de fonctions!
[[1]]
function (...) 
UseMethod("seq")
<bytecode: 0x7ff87bb69938>
<environment: namespace:base>

[[2]]
function (x, ...)  .Primitive("rep")

> 
> ## DÉFINITION D'UNE FONCTION
> 
> ## On définit une nouvelle fonction avec la syntaxe suivante:
> ##
> ##   <nom> <- function(<arguments>) <corps>
> ##
> ## où
> ##
> ## - 'nom' est le nom de la fonction;
> ## - 'arguments' est la liste des arguments, séparés par des
> ##    virgules;
> ## - 'corps' est le corps de la fonction, soit une expression
> ##   ou un groupe d'expressions réunies par des accolades { }.
> ##
> ## Une fonction retourne toujours la valeur de la *dernière*
> ## expression de celle-ci.
> ##
> ## Voici un exemple trivial.
> square <- function(x) x * x
> square(10)
[1] 100
> 
> ## Supposons que l'on veut écrire une fonction pour calculer
> ##
> ##   f(x, y) = x (1 + xy)^2 + y (1 - y) + (1 + xy)(1 - y).
> ##
> ## Deux termes sont répétés dans cette expression. On a donc
> ##
> ##   a = 1 + xy
> ##   b = 1 - y
> ##
> ## et f(x, y) = x a^2 + yb + ab.
> ##
> ## Une manière élégante de procéder au calcul de f(x, y) qui
> ## adopte l'approche fonctionnelle fait appel à une fonction
> ## intermédiaire à l'intérieur de la première fonction. (Il y
> ## a ici des enjeux de «portée lexicale» sur lesquels nous
> ## reviendrons en détail dans un chapitre ultérieur.)
> f <- function(x, y)
+ {
+     g <- function(a, b)
+         x * a^2 + y * b + a * b
+     g(1 + x * y, 1 - y)
+ }
> f(2, 3)
[1] 78
> 
> ## FONCTION ANONYME
> 
> ## Comme le nom du concept l'indique, une fonction anonyme est
> ## une fonction qui n'a pas de nom. C'est parfois utile pour
> ## des fonctions courtes utilisées dans une autre fonction.
> ##
> ## Reprenons l'exemple précédent en généralisant les
> ## expressions des termes 'a' et 'b'. La fonction 'f'
> ## pourrait maintenant prendre en arguments 'x', 'y' et des
> ## fonctions pour calculer 'a' et 'b'.
> f <- function(x, y, fa, fb)
+ {
+     g <- function(a, b)
+         x * a^2 + y * b + a * b
+     g(fa(x, y), fb(x, y))
+ }
> 
> ## Plutôt que de définir deux fonctions pour les arguments
> ## 'fa' et 'fb', on passe directement des fonctions anonymes
> ## en argument.
> f(2, 3,
+   function(x, y) 1 + x * y,
+   function(x, y) 1 - y)
[1] 78
> 
> ## VALEUR PAR DÉFAUT D'UN ARGUMENT
> 
> ## La fonction suivante calcule la distance entre deux points
> ## dans l'espace euclidien à 'n' dimensions, par défaut par
> ## rapport à l'origine.
> ##
> ## Remarquez comment nous spécifions une valeur par défaut,
> ## l'origine, pour l'argument 'y'.
> ##
> ## (Note: la fonction 'sum' effectue... la somme de tous les
> ## éléments d'un vecteur.)
> dist <- function(x, y = 0) sum((x - y)^2)
> 
> ## Quelques calculs de distances.
> dist(c(1, 1))                # (1, 1) par rapport à l'origine
[1] 2
> dist(c(1, 1, 1), c(3, 1, 2)) # entre (1, 1, 1) et (3, 1, 2)
[1] 5
> 
> ## ARGUMENT '...'
> 
> ## Nous illustrons l'utilisation de l'argument '...' de la
> ## manière suivante pour le moment. Nous utiliserons davantage
> ## cet argument avec les fonctions d'application.
> ##
> ## La fonction 'curve' prend en argument une expression
> ## mathématique et trace la fonction pour un intervalle donné.
> curve(x^2, from = 0, to = 2)
> 
> ## Nous souhaitons, pour une raison quelconque, que tous nos
> ## graphiques de ce type (et seulement de ce type) soient
> ## tracés en orange.
> curve(x^2, from = 0, to = 2, col = "orange")
> 
> ## Plutôt que de redéfinir entièrement la fonction 'curve'
> ## avec tous ses arguments (et il y en a plusieurs), nous
> ## pouvons écrire une petite fonction qui, grâce à l'argument
> ## '...', accepte tous les arguments de 'curve'.
> ocurve <- function(...) curve(..., col = "orange")
> ocurve(x^2, from = 0, to = 2)
> 
> ## APPEL D'UNE FONCTION
> 
> ## L'interpréteur R reconnait un appel de fonction au fait que
> ## le nom de l'objet est suivi de parenthèses ( ).
> ##
> ## Une fonction peut n'avoir aucun argument ou plusieurs. Il
> ## n'y a pas de limite pratique au nombre d'arguments.
> ##
> ## Les arguments d'une fonction peuvent être spécifiés selon
> ## l'ordre établi dans la définition de la fonction.
> ##
> ## Cependant, il est beaucoup plus prudent et *fortement
> ## recommandé* de spécifier les arguments par leur nom avec
> ## une construction de la forme 'nom = valeur', surtout après
> ## les deux ou trois premiers arguments.
> ##
> ## L'ordre des arguments est important; il est donc nécessaire
> ## de les nommer s'ils ne sont pas appelés dans l'ordre.
> ##
> ## Certains arguments ont une valeur par défaut qui sera
> ## utilisée si l'argument n'est pas spécifié dans l'appel de
> ## la fonction.
> ##
> ## Examinons la définition de la fonction 'matrix', qui sert à
> ## créer une matrice à partir d'un vecteur de valeurs.
> args(matrix)
function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 
NULL
> 
> ## La fonction compte cinq arguments et chacun a une valeur
> ## par défaut (ce n'est pas toujours le cas).
> ##
> ## Quel sera le résultat de l'appel ci-dessous?
> matrix()
     [,1]
[1,]   NA
> 
> ## Les invocations de la fonction 'matrix' ci-dessous sont
> ## toutes équivalentes.
> ##
> ## Portez attention si les arguments sont spécifiés par nom ou
> ## par position.
> matrix(1:12, 3, 4)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> matrix(1:12, ncol = 4, nrow = 3)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> matrix(nrow = 3, ncol = 4, data = 1:12)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> matrix(nrow = 3, ncol = 4, byrow = FALSE, 1:12)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> matrix(nrow = 3, ncol = 4, 1:12, FALSE)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> 
> ###
> ### EXPRESSIONS CONDITIONNELLES  
> ###
> 
> ## Débutons par deux petits exemples qui démontrent un usage
> ## adéquat de 'if'.
> x <- c(-1, 2, 3)
> if (any(x < 0)) print("il y a des nombres négatifs")
[1] "il y a des nombres négatifs"
> if (all(x > 0)) print("tous les nombres sont positifs")
> 
> ## Première erreur fréquente dans l'utilisation de 'if': la
> ## condition en argument n'est pas une valeur unique.
> ##
> ## Portez bien attention au message d'avertissement de R: le
> ## test a été effectué, mais uniquement avec la première
> ## valeur du vecteur booléen 'x < 0'. Comme, dans le présent
> ## exemple, la première valeur de 'x' est négative,
> ## l'expression 'print' est exécutée.
> if (x < 0)  print("il y a des nombres négatifs")
[1] "il y a des nombres négatifs"
Warning message:
In if (x < 0) print("il y a des nombres négatifs") :
  la condition a une longueur > 1 et seul le premier élément est utilisé
> 
> ## Seconde erreur fréquente: tester que vrai est vrai. (Ce
> ## n'est pas une «erreur» au sens propre puisque la syntaxe
> ## est valide, mais c'est un non-sens sémantique, une forme de
> ## pléonasme comme «monter en haut» ou «deux jumeaux».)
> ##
> ## Voici un exemple de construction avec un test inutile. Le
> ## résultat de 'any' est déjà TRUE ou FALSE, alors pas besoin
> ## de vérifier si TRUE == TRUE ou si FALSE == TRUE. Comparez
> ## avec la version sémantiquement correcte, ci-dessus.
> if (any(x < 0) == TRUE) print("il y a des nombres négatifs")
[1] "il y a des nombres négatifs"
> 
> ## Voici trois mises en oeuvre de la fonction valeur absolue
> ## accompagnées de leur algorithme. Elles vont de la plus
> ## (inutilement) compliquée à la plus simple (sans
> ## aller jusqu'à utiliser la fonction interne 'abs').
> ##
> ## Attention: ces fonctions ne sont pas vectorielles.
> ## (Pourquoi?)
> ##
> ## Algorithme 1 (trois clauses)
> ##   abs(réel x)
> ##     Si (x > 0)
> ##       Retourner x
> ##     Sinon si (x = 0)
> ##       Retourner 0
> ##     Sinon
> ##       Retourner -x
> ##   Fin abs
> abs <- function(x)
+ {
+     if (x > 0)
+         x
+     else if (x == 0)
+         0
+     else
+         -x
+ }
> abs(5)
[1] 5
> abs(0)
[1] 0
> abs(-2)
[1] 2
> 
> ## Algorithme 2 (deux clauses)
> ##   abs(réel x)
> ##     Si (x < 0)
> ##       Retourner -x
> ##     Sinon
> ##       Retourner x
> ##   Fin abs
> abs <- function(x)
+ {
+     if (x < 0)
+         -x
+     else
+         x
+ }
> abs(5)
[1] 5
> abs(0)
[1] 0
> abs(-2)
[1] 2
> 
> ## Algorithme 3 (une seule clause; requiert 'return')
> ##   abs(réel x)
> ##     Si (x < 0)
> ##       Retourner -x
> ##     Retourner x
> ##   Fin abs
> abs <- function(x)
+ {
+     if (x < 0)
+         return(-x)
+     x
+ }
> abs(5)
[1] 5
> abs(0)
[1] 0
> abs(-2)
[1] 2
> 
> ## Détail intéressant sur la structure 'if ... else ...': il
> ## est possible de l'utiliser comme une fonction normale,
> ## c'est-à-dire d'affecter le résultat de la structure à une
> ## variable.
> ##
> ## D'abord, le style de programmation le plus usuel:
> ## l'affectation est effectuée à l'intérieur des clauses 'if'
> ## et 'else'.
> f <- function(y)
+ {
+     if (y < 0)
+         x <- "rouge"
+     else
+         x <- "jaune"
+     paste("la couleur est:", x)
+ }
> f(-2)
[1] "la couleur est: rouge"
> f(3)
[1] "la couleur est: jaune"
> 
> ## Ensuite, la version où le résultat de 'if ... else ...' est
> ## directement affecté dans la variable. C'est plus compact et
> ## très lisible si la conséquence et l'alternative sont des
> ## expressions courtes.
> f <- function(y)
+ {
+     x <- if (y < 0) "rouge" else "jaune"
+     paste("la couleur est:", x)
+ }
> f(-2)
[1] "la couleur est: rouge"
> f(3)
[1] "la couleur est: jaune"
> 
> ## De l'inefficacité de 'ifelse'.
> ##
> ## Supposons que l'on veut une fonction *vectorielle* pour calculer
> ##
> ##   f(x) = x + 2, si x < 0
> ##        = x^2,   si x >= 0.
> ##
> ## On se tourne naturellement vers ifelse() pour ce genre de
> ## calcul. Voyons voir le temps de calcul.
> x <- sample(-10:10, 1e6, replace = TRUE)
> system.time(ifelse(x < 0, x + 2, x^2))
utilisateur     système      écoulé 
      0.035       0.013       0.048 
> 
> ## Solution alternative n'ayant pas recours à ifelse(). C'est
> ## plus long à programmer, mais l'exécution est néanmoins plus
> ## rapide.
> f <- function(x)
+ {
+    y <- numeric(length(x)) # contenant
+    w <- x < 0              # x < 0 ou non
+    y[w] <- x[w] + 2        # calcul pour les x < 0
+    w <- !w                 # x >= 0 ou non
+    y[w] <- x[w]^2          # calcul pour les x >= 0
+    y
+ }
> system.time(f(x))
utilisateur     système      écoulé 
      0.031       0.003       0.034 
> 
> ###
> ### QUELQUES FONCTIONS INTERNES UTILES  
> ###
> 
> ## Pour les exemples qui suivent, on se donne un vecteur non
> ## ordonné.
> x <- c(50, 30, 10, 20, 60, 30, 20, 40)
> 
> ## FONCTIONS MATHÉMATIQUES ET TRIGONOMÉTRIQUES
> 
> ## R contient des fonctions pour calculer la plupart des
> ## fonctions mathématiques et trigonométriques usuelles.
> exp(c(1, 2, -1))           # exponentielle
[1] 2.7182818 7.3890561 0.3678794
> log(exp(c(1, 2, -1)))      # logarithme naturel
[1]  1  2 -1
> log10(c(1, 10, 100))       # logarithme en base 10
[1] 0 1 2
> log(c(1, 5, 25), base = 5) # logarithme en base quelconque
[1] 0 1 2
> sqrt(x)                    # racine carrée
[1] 7.071068 5.477226 3.162278 4.472136 7.745967 5.477226 4.472136 6.324555
> abs(x - mean(x))           # valeur absolue
[1]  17.5  -2.5 -22.5 -12.5  27.5  -2.5 -12.5   7.5
Warning message:
In if (x < 0) return(-x) :
  la condition a une longueur > 1 et seul le premier élément est utilisé
> gamma(1:5)                 # fonction gamma
[1]  1  1  2  6 24
> factorial(0:4)             # factorielle
[1]  1  1  2  6 24
> ?gamma                     # toutes les fonctions apparentées
Special                  package:base                  R Documentation

_S_p_e_c_i_a_l _F_u_n_c_t_i_o_n_s _o_f _M_a_t_h_e_m_a_t_i_c_s

_D_e_s_c_r_i_p_t_i_o_n:

     Special mathematical functions related to the beta and gamma
     functions.

_U_s_a_g_e:

     beta(a, b)
     lbeta(a, b)
     
     gamma(x)
     lgamma(x)
     psigamma(x, deriv = 0)
     digamma(x)
     trigamma(x)
     
     choose(n, k)
     lchoose(n, k)
     factorial(x)
     lfactorial(x)
     
_A_r_g_u_m_e_n_t_s:

    a, b: non-negative numeric vectors.

    x, n: numeric vectors.

k, deriv: integer vectors.

_D_e_t_a_i_l_s:

     The functions ‘beta’ and ‘lbeta’ return the beta function and the
     natural logarithm of the beta function,

                    B(a,b) = Gamma(a)Gamma(b)/Gamma(a+b).               
     
     The formal definition is

                     integral_0^1 t^(a-1) (1-t)^(b-1) dt                
     
     (Abramowitz and Stegun section 6.2.1, page 258).  Note that it is
     only defined in R for non-negative ‘a’ and ‘b’, and is infinite if
     either is zero.

     The functions ‘gamma’ and ‘lgamma’ return the gamma function
     Gamma(x) and the natural logarithm of _the absolute value of_ the
     gamma function.  The gamma function is defined by (Abramowitz and
     Stegun section 6.1.1, page 255)

                Gamma(x) = integral_0^Inf t^(x-1) exp(-t) dt            
     
     for all real ‘x’ except zero and negative integers (when ‘NaN’ is
     returned).  There will be a warning on possible loss of precision
     for values which are too close (within about 1e-8) to a negative
     integer less than ‘-10’.

     ‘factorial(x)’ (x! for non-negative integer ‘x’) is defined to be
     ‘gamma(x+1)’ and ‘lfactorial’ to be ‘lgamma(x+1)’.

     The functions ‘digamma’ and ‘trigamma’ return the first and second
     derivatives of the logarithm of the gamma function.  ‘psigamma(x,
     deriv)’ (‘deriv >= 0’) computes the ‘deriv’-th derivative of
     psi(x).

       digamma(x) = psi(x) = d/dx{ln Gamma(x)} = Gamma'(x) / Gamma(x)   
     
     psi and its derivatives, the ‘psigamma()’ functions, are often
     called the ‘polygamma’ functions, e.g. in Abramowitz and Stegun
     (section 6.4.1, page 260); and higher derivatives (‘deriv = 2:4’)
     have occasionally been called ‘tetragamma’, ‘pentagamma’, and
     ‘hexagamma’.

     The functions ‘choose’ and ‘lchoose’ return binomial coefficients
     and the logarithms of their absolute values.  Note that ‘choose(n,
     k)’ is defined for all real numbers n and integer k.  For k >= 1
     it is defined as n(n-1)...(n-k+1) / k!, as 1 for k = 0 and as 0
     for negative k.  Non-integer values of ‘k’ are rounded to an
     integer, with a warning.

     ‘choose(*, k)’ uses direct arithmetic (instead of ‘[l]gamma’
     calls) for small ‘k’, for speed and accuracy reasons.  Note the
     function ‘combn’ (package ‘utils’) for enumeration of all possible
     combinations.

     The ‘gamma’, ‘lgamma’, ‘digamma’ and ‘trigamma’ functions are
     internal generic primitive functions: methods can be defined for
     them individually or via the ‘Math’ group generic.

_S_o_u_r_c_e:

     ‘gamma’, ‘lgamma’, ‘beta’ and ‘lbeta’ are based on C translations
     of Fortran subroutines by W. Fullerton of Los Alamos Scientific
     Laboratory (now available as part of SLATEC).

     ‘digamma’, ‘trigamma’ and ‘psigamma’ are based on

     Amos, D. E. (1983). A portable Fortran subroutine for derivatives
     of the psi function, Algorithm 610, _ACM Transactions on
     Mathematical Software_ *9(4)*, 494-502.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole. (For ‘gamma’ and ‘lgamma’.)

     Abramowitz, M. and Stegun, I. A. (1972) _Handbook of Mathematical
     Functions_. New York: Dover.  <URL:
     https://en.wikipedia.org/wiki/Abramowitz_and_Stegun> provides
     links to the full text which is in public domain.
     Chapter 6: Gamma and Related Functions.

_S_e_e _A_l_s_o:

     ‘Arithmetic’ for simple, ‘sqrt’ for miscellaneous mathematical
     functions and ‘Bessel’ for the real Bessel functions.

     For the incomplete gamma function see ‘pgamma’.

_E_x_a_m_p_l_e_s:

     require(graphics)
     
     choose(5, 2)
     for (n in 0:10) print(choose(n, k = 0:n))
     
     factorial(100)
     lfactorial(10000)
     
     ## gamma has 1st order poles at 0, -1, -2, ...
     ## this will generate loss of precision warnings, so turn off
     op <- options("warn")
     options(warn = -1)
     x <- sort(c(seq(-3, 4, length.out = 201), outer(0:-3, (-1:1)*1e-6, "+")))
     plot(x, gamma(x), ylim = c(-20,20), col = "red", type = "l", lwd = 2,
          main = expression(Gamma(x)))
     abline(h = 0, v = -3:0, lty = 3, col = "midnightblue")
     options(op)
     
     x <- seq(0.1, 4, length.out = 201); dx <- diff(x)[1]
     par(mfrow = c(2, 3))
     for (ch in c("", "l","di","tri","tetra","penta")) {
       is.deriv <- nchar(ch) >= 2
       nm <- paste0(ch, "gamma")
       if (is.deriv) {
         dy <- diff(y) / dx # finite difference
         der <- which(ch == c("di","tri","tetra","penta")) - 1
         nm2 <- paste0("psigamma(*, deriv = ", der,")")
         nm  <- if(der >= 2) nm2 else paste(nm, nm2, sep = " ==\n")
         y <- psigamma(x, deriv = der)
       } else {
         y <- get(nm)(x)
       }
       plot(x, y, type = "l", main = nm, col = "red")
       abline(h = 0, col = "lightgray")
       if (is.deriv) lines(x[-1], dy, col = "blue", lty = 2)
     }
     par(mfrow = c(1, 1))
     
     ## "Extended" Pascal triangle:
     fN <- function(n) formatC(n, width=2)
     for (n in -4:10) {
         cat(fN(n),":", fN(choose(n, k = -2:max(3, n+2))))
         cat("\n")
     }
     
     ## R code version of choose()  [simplistic; warning for k < 0]:
     mychoose <- function(r, k)
         ifelse(k <= 0, (k == 0),
                sapply(k, function(k) prod(r:(r-k+1))) / factorial(k))
     k <- -1:6
     cbind(k = k, choose(1/2, k), mychoose(1/2, k))
     
     ## Binomial theorem for n = 1/2 ;
     ## sqrt(1+x) = (1+x)^(1/2) = sum_{k=0}^Inf  choose(1/2, k) * x^k :
     k <- 0:10 # 10 is sufficient for ~ 9 digit precision:
     sqrt(1.25)
     sum(choose(1/2, k)* .25^k)
     

> cos(seq(0, pi, by = pi/4)) # cosinus
[1]  1.000000e+00  7.071068e-01  6.123234e-17 -7.071068e-01 -1.000000e+00
> sin(seq(0, pi, by = pi/4)) # sinus
[1] 0.000000e+00 7.071068e-01 1.000000e+00 7.071068e-01 1.224647e-16
> tan(seq(0, pi, by = pi/4)) # tangente
[1]  0.000000e+00  1.000000e+00  1.633124e+16 -1.000000e+00 -1.224647e-16
> ?Trig                      # toutes les fonctions apparentées
Trig                   package:base                    R Documentation

_T_r_i_g_o_n_o_m_e_t_r_i_c _F_u_n_c_t_i_o_n_s

_D_e_s_c_r_i_p_t_i_o_n:

     These functions give the obvious trigonometric functions.  They
     respectively compute the cosine, sine, tangent, arc-cosine,
     arc-sine, arc-tangent, and the two-argument arc-tangent.

     ‘cospi(x)’, ‘sinpi(x)’, and ‘tanpi(x)’, compute ‘cos(pi*x)’,
     ‘sin(pi*x)’, and ‘tan(pi*x)’.

_U_s_a_g_e:

     cos(x)
     sin(x)
     tan(x)
     
     acos(x)
     asin(x)
     atan(x)
     atan2(y, x)
     
     cospi(x)
     sinpi(x)
     tanpi(x)
     
_A_r_g_u_m_e_n_t_s:

    x, y: numeric or complex vectors.

_D_e_t_a_i_l_s:

     The arc-tangent of two arguments ‘atan2(y, x)’ returns the angle
     between the x-axis and the vector from the origin to (x, y), i.e.,
     for positive arguments ‘atan2(y, x) == atan(y/x)’.

     Angles are in radians, not degrees, for the standard versions
     (i.e., a right angle is pi/2), and in ‘half-rotations’ for ‘cospi’
     etc.

     ‘cospi(x)’, ‘sinpi(x)’, and ‘tanpi(x)’ are accurate for ‘x’ values
     which are multiples of a half.

     All except ‘atan2’ are internal generic primitive functions:
     methods can be defined for them individually or via the ‘Math’
     group generic.

     These are all wrappers to system calls of the same name (with
     prefix ‘c’ for complex arguments) where available.  (‘cospi’,
     ‘sinpi’, and ‘tanpi’ are part of a C11 extension and provided by
     e.g. macOS and Solaris: where not yet available call to ‘cos’
     _etc_ are used, with special cases for multiples of a half.)

_V_a_l_u_e:

     ‘tanpi(0.5)’ is ‘NaN’.  Similarly for other inputs with fractional
     part ‘0.5’.

_C_o_m_p_l_e_x _v_a_l_u_e_s:

     For the inverse trigonometric functions, branch cuts are defined
     as in Abramowitz and Stegun, figure 4.4, page 79.

     For ‘asin’ and ‘acos’, there are two cuts, both along the real
     axis: (-Inf, -1] and [1, Inf).

     For ‘atan’ there are two cuts, both along the pure imaginary axis:
     (-1i*Inf, -1i] and [1i, 1i*Inf).

     The behaviour actually on the cuts follows the C99 standard which
     requires continuity coming round the endpoint in a
     counter-clockwise direction.

     Complex arguments for ‘cospi’, ‘sinpi’, and ‘tanpi’ are not yet
     implemented, and they are a ‘future direction’ of ISO/IEC TS
     18661-4.

_S_4 _m_e_t_h_o_d_s:

     All except ‘atan2’ are S4 generic functions: methods can be
     defined for them individually or via the ‘Math’ group generic.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

     Abramowitz, M. and Stegun, I. A. (1972). _Handbook of Mathematical
     Functions_. New York: Dover.
     Chapter 4. Elementary Transcendental Functions: Logarithmic,
     Exponential, Circular and Hyperbolic Functions

     For ‘cospi’, ‘sinpi’, and ‘tanpi’ the C11 extension ISO/IEC TS
     18661-4:2015 (draft at <URL:
     http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1950.pdf>).

_E_x_a_m_p_l_e_s:

     x <- seq(-3, 7, by = 1/8)
     tx <- cbind(x, cos(pi*x), cospi(x), sin(pi*x), sinpi(x),
                    tan(pi*x), tanpi(x), deparse.level=2)
     op <- options(digits = 4, width = 90) # for nice formatting
     head(tx)
     tx[ (x %% 1) %in% c(0, 0.5) ,]
     options(op)
     

> 
> ## SUITES ET RÉPÉTITION
> 
> ## La fonction 'seq' sert à générer des suites générales. Ses
> ## principaux arguments sont 'from', 'to' et 'by'.
> seq(from = 1, to = 10)       # équivalent à 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(10)                      # idem
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(1, 10, by = 2)           # avec incrément autre que 1
[1] 1 3 5 7 9
> seq(-10, 10, length.out = 5) # incrément automatique
[1] -10  -5   0   5  10
> 
> ## La fonction 'seq_len' génère une suite de longueur 'n' à
> ## partir de 1. C'est une version simplifiée et plus rapide de
> ## 'seq(..., length.out = n)'. De plus, elle est plus robuste
> ## lorsque l'argument est 0.
> seq(10)                    # suite 1, 2, ..., 10
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(1, length.out = 10)    # idem robuste
 [1]  1  2  3  4  5  6  7  8  9 10
> seq_len(10)                # équivalent et plus rapide
 [1]  1  2  3  4  5  6  7  8  9 10
> seq(0)                     # pas ce que l'on penserait!
[1] 1 0
> seq(1, length.out = 0)     # plus prudent
integer(0)
> seq_len(0)                 # plus simple
integer(0)
> 
> ## La fonction 'seq_along' génère une suite de la longueur du
> ## vecteur en argument à partir de 1. C'est une version
> ## simplifiée et plus rapide de 'seq(..., along = x)' et de
> ## 'seq_len(length(x))'.
> seq(1, along = x)            # suite de la longueur de x
[1] 1 2 3 4 5 6 7 8
> seq_len(length(x))           # idem, mais deux fonctions
[1] 1 2 3 4 5 6 7 8
> seq_along(x)                 # plus rapide, plus simple
[1] 1 2 3 4 5 6 7 8
> 
> ## La fonction 'rep' permet de répéter des vecteurs de
> ## plusieurs manières différentes.
> rep(1, 10)                  # utilisation de base
 [1] 1 1 1 1 1 1 1 1 1 1
> rep(x, 2)                   # répéter un vecteur
 [1] 50 30 10 20 60 30 20 40 50 30 10 20 60 30 20 40
> rep(x, each = 4)            # répéter chaque élément
 [1] 50 50 50 50 30 30 30 30 10 10 10 10 20 20 20 20 60 60 60 60 30 30 30 30 20
[26] 20 20 20 40 40 40 40
> rep(x, times = 2, each = 4) # combinaison des arguments
 [1] 50 50 50 50 30 30 30 30 10 10 10 10 20 20 20 20 60 60 60 60 30 30 30 30 20
[26] 20 20 20 40 40 40 40 50 50 50 50 30 30 30 30 10 10 10 10 20 20 20 20 60 60
[51] 60 60 30 30 30 30 20 20 20 20 40 40 40 40
> rep(x, length.out = 20)     # résultat de longueur déterminée
 [1] 50 30 10 20 60 30 20 40 50 30 10 20 60 30 20 40 50 30 10 20
> rep(x, times = 1:8)         # nombre de répétitions différent
 [1] 50 30 30 10 10 10 20 20 20 20 60 60 60 60 60 30 30 30 30 30 30 20 20 20 20
[26] 20 20 20 40 40 40 40 40 40 40 40
>                             # pour chaque élément de 'x'
> 
> ## Pour les deux types de répétitions les plus usuels, il y a
> ## les fonctions 'rep.int' et 'rep_len' qui sont plus rapides
> ## que 'rep'.
> rep.int(x, 2)              # seulement répétition 'times'
 [1] 50 30 10 20 60 30 20 40 50 30 10 20 60 30 20 40
> rep_len(x, 10)             # seulement répétition 'length.out'
 [1] 50 30 10 20 60 30 20 40 50 30
> 
> ## EXTRACTION DU DÉBUT ET DE LA FIN D'UN OBJET
> 
> ## L'idée des fonctions 'head' et 'tail', c'est que l'on se
> ## positionne en tête ou en queue d'un objet pour effectuer
> ## des extractions ou des suppressions de composantes.
> ##
> ## Avec un argument positif, les fonctions extraient des
> ## composantes depuis la tête ou la queue de l'objet. Avec un
> ## argument négatif, elles suppriment des composantes à
> ## l'«autre bout» de l'objet.
> head(x, 3)                 # trois premiers éléments
[1] 50 30 10
> head(x, -2)                # tous sauf les deux derniers
[1] 50 30 10 20 60 30
> tail(x, 3)                 # trois derniers éléments
[1] 30 20 40
> tail(x, -2)                # tous sauf les deux premiers
[1] 10 20 60 30 20 40
> 
> ## Les fonctions sont aussi valides sur les matrices et les
> ## data frames. Elles extraient ou suppriment alors des lignes
> ## entières.
> m <- matrix(1:30, 5, 6)    # matrice 5 x 6
> head(m, 3)                 # trois premières lignes
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    6   11   16   21   26
[2,]    2    7   12   17   22   27
[3,]    3    8   13   18   23   28
> tail(m, -2)                # sans les deux premières lignes
     [,1] [,2] [,3] [,4] [,5] [,6]
[3,]    3    8   13   18   23   28
[4,]    4    9   14   19   24   29
[5,]    5   10   15   20   25   30
> 
> ## ARRONDI
> (x <- c(-21.2, -pi, -1.5, -0.2, 0, 0.2, 1.7823, 315))
[1] -21.200000  -3.141593  -1.500000  -0.200000   0.000000   0.200000   1.782300
[8] 315.000000
> round(x)                   # arrondi à l'entier
[1] -21  -3  -2   0   0   0   2 315
> round(x, 2)                # arrondi à la seconde décimale
[1] -21.20  -3.14  -1.50  -0.20   0.00   0.20   1.78 315.00
> round(x, -1)               # arrondi aux dizaines
[1] -20   0   0   0   0   0   0 320
> ceiling(x)                 # plus petit entier supérieur
[1] -21  -3  -1   0   0   1   2 315
> floor(x)                   # plus grand entier inférieur
[1] -22  -4  -2  -1   0   0   1 315
> trunc(x)                   # troncature des décimales
[1] -21  -3  -1   0   0   0   1 315
> 
> ## TESTS LOGIQUES
> 
> ## Les fonctions 'any' et 'all' prennent en argument un
> ## vecteur booléen et elles indiquent, respectivement, si au
> ## moins une ou si toutes les valeurs sont TRUE.
> any(c(TRUE, FALSE, FALSE))  # au moins une valeur TRUE
[1] TRUE
> any(c(FALSE, FALSE, FALSE)) # aucune valeur TRUE
[1] FALSE
> all(c(TRUE, TRUE, TRUE))    # toutes les valeurs TRUE
[1] TRUE
> all(c(TRUE, FALSE, TRUE))   # aucune valeur TRUE
[1] FALSE
> 
> ## Les fonctions sont des compléments l'une de l'autre: si
> ## 'any(x)' est TRUE, alors 'all(!x)' est FALSE, et
> ## vice-versa.
> any(c(TRUE, FALSE, FALSE))   # TRUE
[1] TRUE
> all(!c(TRUE, FALSE, FALSE))  # complément: FALSE
[1] FALSE
> any(c(FALSE, FALSE, FALSE))  # FALSE
[1] FALSE
> all(!c(FALSE, FALSE, FALSE)) # complément: TRUE
[1] TRUE
> 
> ## Les fonctions sont habituellement utilisées avec une
> ## expression logique en argument.
> x                          # rappel
[1] -21.200000  -3.141593  -1.500000  -0.200000   0.000000   0.200000   1.782300
[8] 315.000000
> x > 50                     # valeurs > 50?
[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
> x <= 50                    # valeurs <= 50?
[1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
> any(x > 50)                # y a-t-il des valeurs > 50?
[1] TRUE
> all(x <= 50)               # complément
[1] FALSE
> all(x > 50)                # toutes les valeurs > 50?
[1] FALSE
> any(x <= 50)               # complément
[1] TRUE
> 
> ## SOMMAIRES ET STATISTIQUES DESCRIPTIVES
> sum(x)                     # somme des éléments
[1] 290.9407
> prod(x)                    # produit des éléments
[1] 0
> diff(x)                    # x[2] - x[1], x[3] - x[2], etc.
[1]  18.058407   1.641593   1.300000   0.200000   0.200000   1.582300 313.217700
> mean(x)                    # moyenne des éléments
[1] 36.36759
> mean(x, trim = 0.125)      # moyenne sans minimum et maximum
[1] -0.4765488
> var(x)                     # variance (sans biais)
[1] 12729.86
> sd(x)                      # écart type
[1] 112.8267
> max(x)                     # maximum
[1] 315
> min(x)                     # minimum
[1] -21.2
> range(x)                   # c(min(x), max(x))
[1] -21.2 315.0
> diff(range(x))             # étendue de 'x'
[1] 336.2
> median(x)                  # médiane (50e quantile) empirique
[1] -0.1
> quantile(x)                # quantiles empiriques
        0%        25%        50%        75%       100% 
-21.200000  -1.910398  -0.100000   0.595575 315.000000 
> quantile(x, 1:10/10)       # on peut spécifier les quantiles
       10%        20%        30%        40%        50%        60%        70% 
 -8.559115  -2.484956  -1.370000  -0.460000  -0.100000   0.040000   0.180000 
       80%        90%       100% 
  1.149380  95.747610 315.000000 
> summary(x)                 # plusieurs des résultats ci-dessus
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-21.2000  -1.9104  -0.1000  36.3676   0.5956 315.0000 
> 
> ## SOMMAIRES CUMULATIFS ET COMPARAISONS ÉLÉMENT PAR ÉLÉMENT
> (x <- sample(1:20, 6))
[1]  2  9  4 12 16 15
> (y <- sample(1:20, 6))
[1]  2 18 19 14  4 12
> cumsum(x)                  # somme cumulative de 'x'
[1]  2 11 15 27 43 58
> cumprod(y)                 # produit cumulatif de 'y'
[1]      2     36    684   9576  38304 459648
> rev(cumprod(rev(y)))       # produit cumulatif renversé
[1] 459648 229824  12768    672     48     12
> cummin(x)                  # minimum cumulatif
[1] 2 2 2 2 2 2
> cummax(y)                  # maximum cumulatif
[1]  2 18 19 19 19 19
> pmin(x, y)                 # minimum élément par élément
[1]  2  9  4 12  4 12
> pmax(x, y)                 # maximum élément par élément 
[1]  2 18 19 14 16 15
> 
